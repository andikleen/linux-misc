#
# Support for gcc link time optimization
#

DISABLE_LTO :=
LTO_CFLAGS :=

export DISABLE_LTO
export LTO_CFLAGS

ifdef CONFIG_LTO

# all these checks below should be in Kconfig, but we can't check
# the compiler/linker versions here. So check if everything is ok,
# and if not disable LTO

NO_LTO :=

# 4.7 works mostly, but it sometimes loses symbols on large builds
# This can be worked around by marking those symbols visible,
# but that is fairly ugly and the problem is gone with 4.8
# So only allow it with 4.8 for now.
ifneq ($(call cc-ifversion, -ge, 0408,y),y)
    NO_LTO := y
    $(warning "WARNING: GCC $(call cc-version) too old for LTO/WHOPR. CONFIG_LTO disabled")
endif

# Note that even 4.8 is deprecated, as it is much slower building
# than newer compilers.
ifneq ($(call cc-ifversion, -ge, 0409,y),y)
    $(warning "WARNING: GCC $(call cc-version) builds slower and is deprecated for LTO.")
endif

# We need HJ Lu's Linux binutils because mainline binutils does not
# support mixing assembler and LTO code in the same ld -r object.
# Should check if the gcc plugin ld is the expected one too
# XXX some Fedora binutils should also support it. How to check for that?
ifneq ($(call ld-ifversion,-ge,22710001,y),y)
    NO_LTO := 1
    $(warning "WARNING: Too old linker version $(call ld-version) for kernel LTO.")
    $(warning "WARNING: You need Linux binutils. CONFIG_LTO disabled.")
endif

# Check for options that need specific compiler versions

# needs -mrecord-mcount support
ifeq (${CONFIG_FUNCTION_TRACER},y)
ifneq ($(call cc-ifversion,-ge, 0500,y),y)
    NO_LTO := 1
    $(warning "WARNING: CONFIG_FUNCTION_TRACER needs at least gcc 5 for LTO. Disabling LTO.")
endif
endif

ifeq (${CONFIG_MODVERSIONS},y)
ifneq ($(call cc-ifversion,-ge, 0409,y),y)
    NO_LTO := 1
    $(warning "WARNING: CONFIG_MODVERSIONS needs at least gcc 4.9 for LTO. Disabling LTO.")
endif
endif

# needs per file -pg
ifeq (${CONFIG_GCOV_KERNEL},y)
ifneq ($(call cc-ifversion,-ge, 0500,y),y)
    NO_LTO := 1
    $(warning "WARNING: CONFIG_GCOV_KERNEL needs at least gcc 5.0 for LTO. Disabling LTO.")
endif
endif

# gcc 5.0 supports __attribute__((no_reorder)), so we don't
# need to disable reordering globally, but can only use
# it on init calls.
# the -fno-toplevel-reorder is to preserve the order of initcalls
# everything else should tolerate reordering
ifeq ($(call cc-ifversion,-ge,0500,y),y)
    DISABLE_TL_REORDER :=
else
    DISABLE_TL_REORDER := -fno-toplevel-reorder
endif

LTO_CFLAGS := -flto $(DISABLE_TL_REORDER)
LTO_FINAL_CFLAGS := -fuse-linker-plugin

LTO_FINAL_CFLAGS += $(DISABLE_TL_REORDER)

# enable LTO and set the jobs used by the LTO phase
# this should be -flto=jobserver to coordinate with the
# parent make, but work around
# http://gcc.gnu.org/bugzilla/show_bug.cgi?id=50639
# use as many jobs as processors are online for now
# this actually seems to be a kernel pipe bug?
LTO_FINAL_CFLAGS := -flto=$(shell getconf _NPROCESSORS_ONLN)
#LTO_FINAL_CFLAGS := -flto=jobserver

# Avoid backup code generation in LGEN. This dramatically
# speeds up the build and avoids accidential non LTO use
# requires plugin ar passed and Linux binutils
# Without it it may be possible to use FSF binutils
LTO_CFLAGS += -fno-fat-lto-objects

LTO_FINAL_CFLAGS += --param max-inline-insns-auto=10000

ifdef CONFIG_LTO_DEBUG
    # -dH makes the compiler dump core on crashes to make it easier to debug
    # The ipa and inline graphs allow to understand the LTO code generation
    # They also contain a call tree of the whole program
    LTO_FINAL_CFLAGS += -dH -fdump-ipa-cgraph -fdump-ipa-inline-details
    # -Wl,-plugin-save-temps -save-temps
    LTO_CFLAGS +=
endif

# In principle gcc should pass through options in the object files,
# but it doesn't always work. So do it here manually
# Note that special options for individual files do not work
# before 5.0 (and also there only some limited ones)
# (except for some special cases that only affect the compiler frontend)
LTO_FINAL_CFLAGS += $(filter -g%,${KBUILD_CFLAGS})
LTO_FINAL_CFLAGS += $(filter -O%,${KBUILD_CFLAGS})
LTO_FINAL_CFLAGS += $(filter -f%,${KBUILD_CFLAGS})
LTO_FINAL_CFLAGS += $(filter -m%,${KBUILD_CFLAGS})
LTO_FINAL_CFLAGS += $(filter -W%,${KBUILD_CFLAGS})

# does the compiler really support all the flags we came up with?
ifeq ($(call cc-option,${LTO_CFLAGS} ${LTO_FINAL_CFLAGS},n),n)
    NO_LTO := y
    $(warning "WARNING: Compiler/Linker does not support LTO fully. CONFIG_LTO disabled.")
endif

# if everything passed finally enable LTO
ifeq (${NO_LTO},)
    # Used to disable LTO for specific files (e.g. vdso)
    DISABLE_LTO := -fno-lto
    # generate LTO code at parsing time
    KBUILD_CFLAGS += ${LTO_CFLAGS}
    # use a wrapper to turn ld arguments into gcc and finally do LTO
    LDFINAL := ${CONFIG_SHELL} ${srctree}/scripts/gcc-ld ${LTO_FINAL_CFLAGS}
endif # !NO_LTO
endif # CONFIG_LTO
